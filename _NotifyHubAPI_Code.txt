# NotifyHubAPI - 邮件通知API服务
## 项目概述
独立的邮件通知API服务，基于ASP.NET Core Web API开发
为多个项目提供统一的邮件发送功能，支持多租户、重试机制、状态跟踪等功能

## 文件索引

### 根目录
- GlobalUsings.cs (652 B)
- NotifyHubAPI.csproj (1.9 KB)
- Program.cs (11.1 KB)
- appsettings.Development.json (603 B)
- appsettings.Production.json (925 B)
- appsettings.json (3.5 KB)

### Controllers
- Controllers\EmailController.cs (9.0 KB)

### Middleware
- Middleware\ApiKeyMiddleware.cs (8.0 KB)
- Middleware\GlobalExceptionMiddleware.cs (7.4 KB)
- Middleware\HostFilteringMiddleware.cs (3.8 KB)
- Middleware\RequestValidationMiddleware.cs (7.2 KB)
- Middleware\SecurityHeadersMiddleware.cs (2.9 KB)
- Middleware\SecurityScanDetectionMiddleware.cs (6.9 KB)

### Models
- Models\ApiResponse.cs (1.2 KB)
- Models\EmailRecord.cs (1.7 KB)
- Models\EmailRequest.cs (1.3 KB)
- Models\ErrorHandlingOptions.cs (1.6 KB)
- Models\StandardApiResponse.cs (5.1 KB)

### Services
- Services\ApiKeyService.cs (3.6 KB)
- Services\EmailService.cs (5.5 KB)
- Services\IEmailService.cs (2.3 KB)
- Services\SmtpSettings.cs (473 B)

## 项目统计
- 总文件数: 22
- 总大小: 86.4 KB
- 生成时间: 2025-09-26 21:22:51
- 项目路径: D:\Programing\C#\NotifyHubAPI\NotifyHubAPI

## 技术栈
- ASP.NET Core 8.0 Web API
- Entity Framework Core (SQL Server)
- MailKit (邮件发送)
- Serilog (日志记录)
- AspNetCoreRateLimit (速率限制)

================================================================================
## 文件内容
================================================================================


### 根目录 文件夹
--------------------------------------------------

#### 文件: GlobalUsings.cs
```csharp
﻿// 全局 using 声明，避免在每个文件中重复引用常用命名空间

global using System;
global using System.Collections.Generic;
global using System.ComponentModel.DataAnnotations;
global using System.Linq;
global using System.Threading;
global using System.Threading.Tasks;

global using Microsoft.AspNetCore.Mvc;
global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Hosting;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Options;

global using NotifyHubAPI.Models;
global using NotifyHubAPI.Services;
```

#### 文件: NotifyHubAPI.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<UserSecretsId>NotifyHubAPI-2024</UserSecretsId>
		<DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
	</PropertyGroup>

	<ItemGroup>
	  <Compile Remove="Deploy\**" />
	  <Compile Remove="Extensions\**" />
	  <Content Remove="Deploy\**" />
	  <Content Remove="Extensions\**" />
	  <EmbeddedResource Remove="Deploy\**" />
	  <EmbeddedResource Remove="Extensions\**" />
	  <None Remove="Deploy\**" />
	  <None Remove="Extensions\**" />
	</ItemGroup>

	<ItemGroup>
		<!-- ASP.NET Core 相关包 -->
		<PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
		<PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />

		<!-- 健康检查相关包 -->
		<PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="8.0.0" />

		<!-- 日志相关包 -->
		<PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
		<PackageReference Include="Serilog.Sinks.Console" Version="5.0.0" />
		<PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />

		<!-- 验证和安全相关包 -->
		<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
		<PackageReference Include="System.ComponentModel.Annotations" Version="5.0.0" />

		<!-- 速率限制包 -->
		<PackageReference Include="AspNetCoreRateLimit" Version="5.0.0" />

		<!-- 邮件发送包 -->
		<PackageReference Include="MailKit" Version="4.7.1" />
		<PackageReference Include="MimeKit" Version="4.7.1" />
	</ItemGroup>

	<ItemGroup>
	  <Content Update="appsettings.Development.json">
	    <CopyToOutputDirectory>Never</CopyToOutputDirectory>
	  </Content>
	  <Content Update="web.config">
	    <CopyToOutputDirectory>Always</CopyToOutputDirectory>
	  </Content>
	</ItemGroup>

</Project>
```

#### 文件: Program.cs
```csharp
using NotifyHubAPI.Services;
using NotifyHubAPI.Middleware;
using Serilog;
using AspNetCoreRateLimit;
using Microsoft.AspNetCore.Server.Kestrel.Core;

var builder = WebApplication.CreateBuilder(args);

//  Serilog
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .WriteTo.File("logs/notifyhub-.log", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();

// ÷
ConfigureServices(builder.Services, builder.Configuration);

var app = builder.Build();

// HTTPܵ
ConfigurePipeline(app);

Log.Information("NotifyHubAPI : {Urls}", string.Join(", ", app.Urls));

try
{
    await app.RunAsync();
}
catch (Exception ex)
{
    Log.Fatal(ex, "Ӧóʧ");
}
finally
{
    Log.CloseAndFlush();
}

void ConfigureServices(IServiceCollection services, IConfiguration configuration)
{
    // 
    services.AddControllers();
    services.AddEndpointsApiExplorer();

    // С
    services.Configure<IISServerOptions>(options =>
    {
        options.MaxRequestBodySize = configuration.GetValue<long>("Security:MaxRequestSizeBytes", 1024 * 1024);
    });

    services.Configure<KestrelServerOptions>(options =>
    {
        options.Limits.MaxRequestBodySize = configuration.GetValue<long>("Security:MaxRequestSizeBytes", 1024 * 1024);
    });

    services.AddSwaggerGen(c =>
    {
        c.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
        {
            Title = "NotifyHub API",
            Version = "v1.0",
            Description = "ͳһʼ֪ͨAPI - ΪĿṩͳһʼ֪ͨ",
            Contact = new Microsoft.OpenApi.Models.OpenApiContact
            {
                Name = "NotifyHub Team",
                Email = "admin@notify.origami7023.cn"
            }
        });

        // API Key֤Swagger
        c.AddSecurityDefinition("ApiKey", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
        {
            Description = "API Key֤ (Header: X-API-Key  Authorization: Bearer {key})",
            Name = "X-API-Key",
            In = Microsoft.OpenApi.Models.ParameterLocation.Header,
            Type = Microsoft.OpenApi.Models.SecuritySchemeType.ApiKey,
            Scheme = "ApiKeyScheme"
        });

        c.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
        {
            {
                new Microsoft.OpenApi.Models.OpenApiSecurityScheme
                {
                    Reference = new Microsoft.OpenApi.Models.OpenApiReference
                    {
                        Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                        Id = "ApiKey"
                    }
                },
                Array.Empty<string>()
            }
        });
    });

    // SMTP - ȴӻȡֵ
    services.Configure<SmtpSettings>(options =>
    {
        var smtpHost = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_HOST");
        if (!string.IsNullOrEmpty(smtpHost))
            options.Host = smtpHost;

        var smtpPort = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_PORT");
        if (!string.IsNullOrEmpty(smtpPort) && int.TryParse(smtpPort, out var port))
            options.Port = port;

        var smtpUseSsl = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_USESSL");
        if (!string.IsNullOrEmpty(smtpUseSsl) && bool.TryParse(smtpUseSsl, out var useSsl))
            options.UseSsl = useSsl;

        var smtpUsername = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_USERNAME");
        if (!string.IsNullOrEmpty(smtpUsername))
            options.Username = smtpUsername;

        var smtpPassword = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_PASSWORD");
        if (!string.IsNullOrEmpty(smtpPassword))
            options.Password = smtpPassword;

        var smtpFromEmail = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_FROMEMAIL");
        if (!string.IsNullOrEmpty(smtpFromEmail))
            options.FromEmail = smtpFromEmail;

        var smtpFromName = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_FROMNAME");
        if (!string.IsNullOrEmpty(smtpFromName))
            options.FromName = smtpFromName;
    });

    // ע
    services.AddScoped<IEmailService, SimpleEmailService>();
    services.AddSingleton<IApiKeyService, ApiKeyService>();

    // ڴ滺
    services.AddMemoryCache();
    services.Configure<IpRateLimitOptions>(configuration.GetSection("IpRateLimiting"));
    services.Configure<IpRateLimitPolicies>(configuration.GetSection("IpRateLimitPolicies"));
    services.AddInMemoryRateLimiting();
    services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();

    // 
    services.AddHealthChecks()
        .AddCheck("smtp", () =>
        {
            try
            {
                var smtpHost = Environment.GetEnvironmentVariable("NOTIFYHUB_SMTP_HOST");
                return !string.IsNullOrEmpty(smtpHost)
                    ? Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Healthy("SMTP")
                    : Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Unhealthy("SMTPȱʧ");
            }
            catch (Exception ex)
            {
                return Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Unhealthy($"SMTPʧ: {ex.Message}");
            }
        })
        .AddCheck("apikeys", () =>
        {
            try
            {
                var envVars = Environment.GetEnvironmentVariables()
                    .Cast<System.Collections.DictionaryEntry>()
                    .Count(kv => kv.Key.ToString()?.StartsWith("NOTIFYHUB_APIKEY_") == true);

                return envVars > 0
                    ? Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Healthy($"Ѽ{envVars}APIԿ")
                    : Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Unhealthy("δҵAPIԿ");
            }
            catch (Exception ex)
            {
                return Microsoft.Extensions.Diagnostics.HealthChecks.HealthCheckResult.Unhealthy($"APIԿʧ: {ex.Message}");
            }
        });

    // CORS
    services.AddCors(options =>
    {
        options.AddPolicy("AllowOrigins", policy =>
        {
            var allowedOrigins = configuration.GetSection("Security:AllowedHosts").Get<string[]>()
                ?? new[] { "https://notify.origami7023.cn" };

            // ֻHTTPS origins ()
            var httpsOrigins = allowedOrigins
                .Where(origin => !origin.StartsWith("localhost"))
                .Select(origin => origin.StartsWith("http") ? origin : $"https://{origin}")
                .ToArray();

            if (builder.Environment.IsDevelopment())
            {
                // localhost
                httpsOrigins = httpsOrigins.Concat(new[] { "http://localhost:3000", "https://localhost:7000" }).ToArray();
            }

            policy.WithOrigins(httpsOrigins)
                  .AllowAnyMethod()
                  .AllowAnyHeader()
                  .AllowCredentials();
        });
    });

    // HTTPSض
    if (!builder.Environment.IsDevelopment())
    {
        services.AddHsts(options =>
        {
            options.Preload = true;
            options.IncludeSubDomains = true;
            options.MaxAge = TimeSpan.FromDays(365);
        });
    }
}

void ConfigurePipeline(WebApplication app)
{
    // 
    if (app.Environment.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseSwagger();
        app.UseSwaggerUI(c =>
        {
            c.SwaggerEndpoint("/swagger/v1/swagger.json", "NotifyHub API v1");
            c.RoutePrefix = string.Empty;
        });
    }
    else
    {
        // ǿHTTPS
        app.UseHsts();
    }

    // === ȫм ===
    // 1. ȫ쳣磩
    app.UseGlobalExceptionHandler();

    // 2. ȫɨ⣨֮ǰ
    app.UseSecurityScanDetection();

    // 3. ȫͷ
    if (app.Configuration.GetValue<bool>("Security:EnableSecurityHeaders", true))
    {
        app.UseSecurityHeaders();
    }

    // 4. ˣֱֹIPʣ
    if (app.Configuration.GetValue<bool>("Security:BlockDirectIpAccess", true))
    {
        app.UseCustomHostFiltering();
    }

    // 5. ֤С͡ݣ
    app.UseRequestValidation();

    // 6. HTTPSض
    if (app.Configuration.GetValue<bool>("Security:RequireHttps", true))
    {
        app.UseHttpsRedirection();
    }

    // 7. CORS
    app.UseCors("AllowOrigins");

    // 8. ֤֮ǰ
    app.UseIpRateLimiting();

    // 9. APIԿ֤
    app.UseApiKeyAuthentication();

    // === Ӧóм ===
    app.UseRouting();
    app.UseAuthorization();
    app.MapControllers();

    // === Ϣ˵ ===
    app.MapHealthChecks("/health");
    app.MapHealthChecks("/health/ready", new Microsoft.AspNetCore.Diagnostics.HealthChecks.HealthCheckOptions
    {
        Predicate = check => check.Tags.Contains("ready")
    });
    app.MapHealthChecks("/health/live", new Microsoft.AspNetCore.Diagnostics.HealthChecks.HealthCheckOptions
    {
        Predicate = _ => false
    });

    // Ĭ· - ʾSwagger
    if (app.Environment.IsDevelopment())
    {
        app.MapGet("/", () => Results.Redirect("/swagger"));
    }
    else
    {
        app.MapGet("/", () => Results.Json(new
        {
            message = "NotifyHub API",
            status = "",
            timestamp = DateTime.UtcNow
        }));
    }

    // ״̬Ϣ˵
    app.MapGet("/info", () =>
    {
        try
        {
            return Results.Ok(new
            {
                service = "NotifyHubAPI",
                version = "1.0.0 (Secure)",
                environment = app.Environment.EnvironmentName,
                timestamp = DateTime.UtcNow,
                security = new
                {
                    httpsOnly = app.Configuration.GetValue<bool>("Security:RequireHttps", true),
                    hostFiltering = app.Configuration.GetValue<bool>("Security:BlockDirectIpAccess", true),
                    rateLimiting = true,
                    securityHeaders = app.Configuration.GetValue<bool>("Security:EnableSecurityHeaders", true),
                    requestValidation = true
                },
                features = new
                {
                    emailSending = true,
                    emailHistory = false,
                    retryMechanism = false,
                    persistence = false
                }
            });
        }
        catch (Exception ex)
        {
            app.Logger.LogError(ex, "ȡϢʧ");
            return Results.Problem("Ϣȡʧ");
        }
    }).RequireRateLimiting("DefaultPolicy");
}
```

#### 文件: appsettings.Development.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "NotifyHubAPI": "Debug"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=notifyhub.db"
  },
  "ApiKeys": {
    "NOTIFYHUB_APIKEY_DEFAULT": "nh-prod-7K9mP3xR8wQ2nV5ag4yQWcL8sA9dE3tY7uI2oP6qW1zX5",
  },
  "SmtpSettings": {
    "Host": "smtp.qq.com",
    "Port": 587,
    "UseSsl": true,
    "Username": "2840080918@qq.com",
    "Password": "ojqniznhexwqdhcg",
    "FromEmail": "2840080918@qq.com",
    "FromName": "NotifyHub开发测试"
  }
}
```

#### 文件: appsettings.Production.json
```json
﻿{
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  },
  "SmtpSettings": {
    "Host": "smtp.qq.com",
    "Port": 587,
    "UseSsl": true,
    "Username": "2840080918@qq.com",
    "Password": "ojqniznhexwqdhcg",
    "FromEmail": "2840080918@qq.com",
    "FromName": "NotifyHub"
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "NotifyHubAPI.Middleware.SecurityScanDetectionMiddleware": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/notifyhub.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7,
          "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff} {Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  }
}
```

#### 文件: appsettings.json
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=NotificationApi;Trusted_Connection=true;TrustServerCertificate=true;"
  },
  "SmtpSettings": {
    "Host": "smtp.qq.com",
    "Port": 587,
    "UseSsl": true,
    "Username": "2840080918@qq.com",
    "Password": "ojqniznhexwqdhcg",
    "FromEmail": "2840080918@qq.com",
    "FromName": "通知系统"
  },
  "RateLimiting": {
    "RequestsPerMinute": 60,
    "RequestsPerHour": 1000
  },
  "RetrySettings": {
    "MaxRetryAttempts": 3,
    "RetryDelayMinutes": 5,
    "CheckIntervalMinutes": 5
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Information",
        "Microsoft.EntityFrameworkCore": "Warning",
        "NotifyHubAPI.Middleware.SecurityScanDetectionMiddleware": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "restrictedToMinimumLevel": "Information",
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/notifyhub.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7,
          "fileSizeLimitBytes": 52428800,
          "rollOnFileSizeLimit": true,
          "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff} {Level:u3}] {SourceContext} {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/security-scan.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 3,
          "restrictedToMinimumLevel": "Warning",
          "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss}] {Message:lj}{NewLine}",
          "filterExpression": "@mt like '%安全扫描%' or @mt like '%可疑请求%'"
        }
      }
    ],
    "Enrich": [ "FromLogContext" ]
  },
  "Security": {
    "AllowedHosts": [
      "notify.origami7023.cn",
      "www.notify.origami7023.cn",
      "localhost"
    ],
    "AllowLocalhostAccess": true,
    "MaxRequestSizeBytes": 1048576,
    "BlockDirectIpAccess": true,
    "RequireHttps": true,
    "EnableSecurityHeaders": true,
    "LogSuspiciousActivity": true
  },
  "IpRateLimiting": {
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "RealIpHeader": "X-Real-IP",
    "ClientIdHeader": "X-ClientId",
    "HttpStatusCode": 429,
    "QuotaExceededResponse": {
      "Content": "Rate limit exceeded",
      "ContentType": "text/plain"
    },
    "GeneralRules": [
      {
        "Endpoint": "*",
        "Period": "1m",
        "Limit": 20
      },
      {
        "Endpoint": "*",
        "Period": "1h",
        "Limit": 200
      },
      {
        "Endpoint": "*/api/email/send",
        "Period": "1m",
        "Limit": 5
      },
      {
        "Endpoint": "*/api/email/send",
        "Period": "1h",
        "Limit": 50
      }
    ]
  },
  "IpRateLimitPolicies": {
    "IpRules": [
      {
        "Ip": "127.0.0.1",
        "Rules": [
          {
            "Endpoint": "*",
            "Period": "1m",
            "Limit": 100
          }
        ]
      }
    ]
  }
}
```


### Controllers 文件夹
--------------------------------------------------

#### 文件: Controllers\EmailController.cs
```csharp
﻿using Microsoft.AspNetCore.Mvc;
using NotifyHubAPI.Models;
using NotifyHubAPI.Services;
using System.ComponentModel.DataAnnotations;
using System.Text.RegularExpressions;

namespace NotifyHubAPI.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class EmailController : ControllerBase
    {
        private readonly IEmailService _emailService;
        private readonly IApiKeyService _apiKeyService;
        private readonly ILogger<EmailController> _logger;

        public EmailController(
            IEmailService emailService,
            IApiKeyService apiKeyService,
            ILogger<EmailController> logger)
        {
            _emailService = emailService;
            _apiKeyService = apiKeyService;
            _logger = logger;
        }

        /// <summary>
        /// 发送邮件
        /// </summary>
        /// <param name="request">邮件发送请求</param>
        /// <returns>发送结果</returns>
        [HttpPost("send")]
        [ProducesResponseType(typeof(StandardApiResponse<EmailSendResponse>), 200)]
        [ProducesResponseType(typeof(StandardApiResponse<object>), 400)]
        [ProducesResponseType(typeof(StandardApiResponse<object>), 401)]
        [ProducesResponseType(typeof(StandardApiResponse<object>), 500)]
        public async Task<IActionResult> SendEmail([FromBody] EmailRequest request)
        {
            try
            {
                // 获取API Key
                var apiKey = GetApiKeyFromRequest();
                if (string.IsNullOrEmpty(apiKey))
                {
                    return Unauthorized(StandardApiResponse<object>.CreateUnauthorized("缺少API密钥"));
                }

                // 验证API Key
                if (!_apiKeyService.IsValidApiKey(apiKey))
                {
                    return Unauthorized(StandardApiResponse<object>.CreateUnauthorized("无效的API密钥"));
                }

                // 自定义邮箱验证
                var emailValidationErrors = ValidateEmails(request);
                if (emailValidationErrors.Any())
                {
                    return BadRequest(StandardApiResponse<object>.CreateValidationError(
                        "邮箱格式错误",
                        new Dictionary<string, string[]>
                        {
                            ["emails"] = emailValidationErrors.ToArray()
                        }));
                }

                // 模型验证
                if (!ModelState.IsValid)
                {
                    var errors = ModelState.ToDictionary(
                        kvp => kvp.Key,
                        kvp => kvp.Value?.Errors.Select(e => e.ErrorMessage).ToArray() ?? Array.Empty<string>()
                    );

                    return BadRequest(StandardApiResponse<object>.CreateValidationError(
                        "请求参数错误",
                        errors));
                }

                // 发送邮件
                var result = await _emailService.SendEmailAsync(request, apiKey);

                _logger.LogInformation("邮件发送请求完成，EmailId: {EmailId}, Status: {Status}",
                    result.EmailId, result.Status);

                return Ok(StandardApiResponse<EmailSendResponse>.CreateSuccess(
                    result,
                    "邮件发送请求已处理"));
            }
            catch (ArgumentException ex)
            {
                _logger.LogWarning(ex, "邮件发送参数错误");
                return BadRequest(StandardApiResponse<object>.CreateFailure(
                    "请求参数错误",
                    ApiErrorCode.InvalidParameter));
            }
            catch (InvalidOperationException ex) when (ex.Message.Contains("SMTP"))
            {
                _logger.LogError(ex, "SMTP配置错误");
                return StatusCode(500, StandardApiResponse<object>.CreateFailure(
                    "邮件服务配置错误",
                    ApiErrorCode.ConfigurationError));
            }
            catch (TimeoutException ex)
            {
                _logger.LogError(ex, "邮件发送超时");
                return StatusCode(500, StandardApiResponse<object>.CreateFailure(
                    "邮件发送超时，请稍后重试",
                    ApiErrorCode.ExternalServiceError));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "邮件发送接口异常");
                // 不在这里返回详细错误，让全局异常处理器处理
                throw;
            }
        }

        /// <summary>
        /// 健康检查
        /// </summary>
        /// <returns>服务状态</returns>
        [HttpGet("health")]
        [ProducesResponseType(typeof(StandardApiResponse<HealthCheckResponse>), 200)]
        public IActionResult HealthCheck()
        {
            try
            {
                var response = new HealthCheckResponse
                {
                    Status = "Healthy",
                    Timestamp = DateTime.UtcNow,
                    Version = "1.0.0",
                    Environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Unknown",
                    Components = new Dictionary<string, object>
                    {
                        ["smtp"] = "Available",
                        ["apiKeys"] = _apiKeyService.GetAllApiKeys().Count + " keys loaded",
                        ["mode"] = "Stateless"
                    }
                };

                return Ok(StandardApiResponse<HealthCheckResponse>.CreateSuccess(
                    response,
                    "服务运行正常"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "健康检查异常");
                return StatusCode(500, StandardApiResponse<HealthCheckResponse>.CreateServerError(
                    "健康检查失败"));
            }
        }

        /// <summary>
        /// 从请求中获取API密钥
        /// </summary>
        /// <returns>API密钥</returns>
        private string? GetApiKeyFromRequest()
        {
            // 从Authorization Header获取Bearer Token
            var authHeader = Request.Headers.Authorization.FirstOrDefault();
            if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer "))
            {
                return authHeader.Substring("Bearer ".Length).Trim();
            }

            // 从X-API-Key Header获取
            var apiKeyHeader = Request.Headers["X-API-Key"].FirstOrDefault();
            if (!string.IsNullOrEmpty(apiKeyHeader))
            {
                return apiKeyHeader.Trim();
            }

            return null;
        }

        /// <summary>
        /// 验证邮箱地址格式
        /// </summary>
        /// <param name="request">邮件请求</param>
        /// <returns>验证错误列表</returns>
        private List<string> ValidateEmails(EmailRequest request)
        {
            var errors = new List<string>();
            var emailRegex = new Regex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.Compiled);

            // 验证收件人
            if (request.To?.Any() == true)
            {
                foreach (var email in request.To.Where(e => !string.IsNullOrWhiteSpace(e)))
                {
                    if (!emailRegex.IsMatch(email.Trim()))
                    {
                        errors.Add($"收件人邮箱格式不正确: {email}");
                    }
                }
            }
            else
            {
                errors.Add("收件人不能为空");
            }

            // 验证抄送
            if (request.Cc?.Any() == true)
            {
                foreach (var email in request.Cc.Where(e => !string.IsNullOrWhiteSpace(e)))
                {
                    if (!emailRegex.IsMatch(email.Trim()))
                    {
                        errors.Add($"抄送邮箱格式不正确: {email}");
                    }
                }
            }

            // 验证密送
            if (request.Bcc?.Any() == true)
            {
                foreach (var email in request.Bcc.Where(e => !string.IsNullOrWhiteSpace(e)))
                {
                    if (!emailRegex.IsMatch(email.Trim()))
                    {
                        errors.Add($"密送邮箱格式不正确: {email}");
                    }
                }
            }

            // 检查邮件总数限制（防止滥用）
            var totalRecipients = (request.To?.Count ?? 0) +
                                (request.Cc?.Count ?? 0) +
                                (request.Bcc?.Count ?? 0);

            if (totalRecipients > 100) // 可配置的限制
            {
                errors.Add($"收件人总数不能超过100个，当前: {totalRecipients}");
            }

            return errors;
        }
    }
}
```


### Middleware 文件夹
--------------------------------------------------

#### 文件: Middleware\ApiKeyMiddleware.cs
```csharp
﻿using Microsoft.AspNetCore.Http;
using NotifyHubAPI.Services;
using System.Text.Json;
using System.Text.Encodings.Web;

namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// API密钥认证中间件
    /// 支持多种认证方式：Authorization Bearer Token 和 X-API-Key Header
    /// </summary>
    public class ApiKeyMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ApiKeyMiddleware> _logger;
        private readonly IServiceProvider _serviceProvider;

        // 不需要API Key验证的路径
        private readonly HashSet<string> _excludedPaths = new(StringComparer.OrdinalIgnoreCase)
        {
            "/",
            "/swagger",
            "/swagger/index.html",
            "/swagger/v1/swagger.json",
            "/health",
            "/api/email/health"
        };

        // JSON序列化选项 - 避免Unicode转义
        private readonly JsonSerializerOptions _jsonOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping // 避免Unicode转义
        };

        public ApiKeyMiddleware(RequestDelegate next, ILogger<ApiKeyMiddleware> logger, IServiceProvider serviceProvider)
        {
            _next = next;
            _logger = logger;
            _serviceProvider = serviceProvider;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // 检查是否为排除的路径
            if (IsExcludedPath(context.Request.Path))
            {
                await _next(context);
                return;
            }

            // 获取API Key服务（使用作用域）
            using var scope = _serviceProvider.CreateScope();
            var apiKeyService = scope.ServiceProvider.GetRequiredService<IApiKeyService>();

            // 从请求中获取API Key
            var apiKey = GetApiKeyFromRequest(context);

            if (string.IsNullOrEmpty(apiKey))
            {
                _logger.LogWarning("API请求缺少密钥，路径: {Path}, IP: {IP}",
                    context.Request.Path, GetClientIpAddress(context));
                await WriteUnauthorizedResponse(context, "缺少API密钥");
                return;
            }

            // 验证API Key
            if (!apiKeyService.IsValidApiKey(apiKey))
            {
                _logger.LogWarning("无效的API密钥访问尝试，密钥: {ApiKey}, 路径: {Path}, IP: {IP}",
                    MaskApiKey(apiKey), context.Request.Path, GetClientIpAddress(context));
                await WriteUnauthorizedResponse(context, "无效的API密钥");
                return;
            }

            // 获取项目名称并添加到请求上下文
            var projectName = apiKeyService.GetProjectByApiKey(apiKey);
            if (!string.IsNullOrEmpty(projectName))
            {
                context.Items["ProjectName"] = projectName;
                context.Items["ApiKey"] = apiKey;
            }

            _logger.LogDebug("API密钥验证通过，项目: {ProjectName}, 路径: {Path}",
                projectName ?? "Unknown", context.Request.Path);

            // 继续处理请求
            await _next(context);
        }

        /// <summary>
        /// 检查路径是否在排除列表中
        /// </summary>
        private bool IsExcludedPath(PathString path)
        {
            // 完全匹配
            if (_excludedPaths.Contains(path.Value))
                return true;

            // Swagger相关路径
            if (path.StartsWithSegments("/swagger", StringComparison.OrdinalIgnoreCase))
                return true;

            // 健康检查路径
            if (path.StartsWithSegments("/health", StringComparison.OrdinalIgnoreCase))
                return true;

            return false;
        }

        /// <summary>
        /// 从HTTP请求中获取API密钥
        /// </summary>
        private static string? GetApiKeyFromRequest(HttpContext context)
        {
            // 1. 从Authorization Header获取Bearer Token
            var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
            if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
            {
                return authHeader.Substring("Bearer ".Length).Trim();
            }

            // 2. 从X-API-Key Header获取
            var apiKeyHeader = context.Request.Headers["X-API-Key"].FirstOrDefault();
            if (!string.IsNullOrEmpty(apiKeyHeader))
            {
                return apiKeyHeader.Trim();
            }

            // 3. 从查询参数获取（仅用于开发环境，不推荐生产使用）
            var apiKeyQuery = context.Request.Query["apikey"].FirstOrDefault();
            if (!string.IsNullOrEmpty(apiKeyQuery))
            {
                return apiKeyQuery.Trim();
            }

            return null;
        }

        /// <summary>
        /// 获取客户端IP地址
        /// </summary>
        private static string GetClientIpAddress(HttpContext context)
        {
            // 检查反向代理头
            var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
            if (!string.IsNullOrEmpty(forwardedFor))
            {
                return forwardedFor.Split(',')[0].Trim();
            }

            var realIp = context.Request.Headers["X-Real-IP"].FirstOrDefault();
            if (!string.IsNullOrEmpty(realIp))
            {
                return realIp;
            }

            // 使用连接的远程IP
            return context.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }

        /// <summary>
        /// 掩码API密钥用于日志记录
        /// </summary>
        private static string MaskApiKey(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey))
                return "Empty";

            if (apiKey.Length < 8)
            {
                // 小于8位全隐藏
                return new string('*', apiKey.Length);
            }
            else if (apiKey.Length <= 20)
            {
                // 8-20位隐藏中间8位
                var start = apiKey.Substring(0, 4);
                var end = apiKey.Substring(apiKey.Length - 4);
                return start + new string('*', 8) + end;
            }
            else
            {
                // 大于20位隐藏前后8位中间的部分
                var start = apiKey.Substring(0, 8);
                var end = apiKey.Substring(apiKey.Length - 8);
                var middleLength = apiKey.Length - 16;
                return start + new string('*', middleLength) + end;
            }
        }

        /// <summary>
        /// 写入未授权响应
        /// </summary>
        private async Task WriteUnauthorizedResponse(HttpContext context, string message)
        {
            context.Response.StatusCode = 401;
            context.Response.ContentType = "application/json; charset=utf-8";

            var errorCode = message.Contains("缺少") ?
                ApiErrorCode.MissingApiKey :
                ApiErrorCode.InvalidApiKey;

            var response = StandardApiResponse<object>.CreateFailure(
                message,
                errorCode,
                details: null
            );

            var jsonResponse = JsonSerializer.Serialize(response, _jsonOptions);
            await context.Response.WriteAsync(jsonResponse);
        }
    }

    /// <summary>
    /// API密钥中间件扩展方法
    /// </summary>
    public static class ApiKeyMiddlewareExtensions
    {
        /// <summary>
        /// 添加API密钥认证中间件
        /// </summary>
        public static IApplicationBuilder UseApiKeyAuthentication(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ApiKeyMiddleware>();
        }
    }
}
```

#### 文件: Middleware\GlobalExceptionMiddleware.cs
```csharp
﻿using System.Net;
using System.Text.Json;
using System.Text.Encodings.Web;

namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// 全局异常处理中间件
    /// 统一处理所有未捕获的异常，避免敏感信息泄露
    /// </summary>
    public class GlobalExceptionMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<GlobalExceptionMiddleware> _logger;
        private readonly IWebHostEnvironment _environment;

        // JSON序列化选项
        private readonly JsonSerializerOptions _jsonOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
        };

        public GlobalExceptionMiddleware(
            RequestDelegate next,
            ILogger<GlobalExceptionMiddleware> logger,
            IWebHostEnvironment environment)
        {
            _next = next;
            _logger = logger;
            _environment = environment;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "全局异常捕获 - 路径: {Path}, 方法: {Method}, IP: {IP}, RequestId: {RequestId}",
                    context.Request.Path,
                    context.Request.Method,
                    GetClientIpAddress(context),
                    GetRequestId(context));

                await HandleExceptionAsync(context, ex);
            }
        }

        private async Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            // 避免重复处理已经开始的响应
            if (context.Response.HasStarted)
            {
                _logger.LogWarning("响应已开始，无法处理异常");
                return;
            }

            var requestId = GetRequestId(context);
            var (statusCode, message, details) = GetErrorResponse(exception);

            context.Response.StatusCode = (int)statusCode;
            context.Response.ContentType = "application/json; charset=utf-8";

            var response = new
            {
                success = false,
                message = message,
                requestId = requestId,
                timestamp = DateTime.UtcNow,
                details = _environment.IsDevelopment() ? details : null // 仅开发环境显示详细信息
            };

            var jsonResponse = JsonSerializer.Serialize(response, _jsonOptions);
            await context.Response.WriteAsync(jsonResponse);
        }

        /// <summary>
        /// 根据异常类型返回适当的错误响应
        /// </summary>
        private (HttpStatusCode statusCode, string message, object? details) GetErrorResponse(Exception exception)
        {
            return exception switch
            {
                ArgumentException or ArgumentNullException =>
                    (HttpStatusCode.BadRequest, "请求参数错误", GetSafeExceptionDetails(exception)),

                UnauthorizedAccessException =>
                    (HttpStatusCode.Unauthorized, "未授权访问", null),

                NotImplementedException =>
                    (HttpStatusCode.NotImplemented, "功能暂未实现", null),

                TimeoutException =>
                    (HttpStatusCode.RequestTimeout, "请求超时，请稍后重试", null),

                InvalidOperationException when exception.Message.Contains("API密钥") =>
                    (HttpStatusCode.InternalServerError, "系统配置错误", null),

                HttpRequestException =>
                    (HttpStatusCode.BadGateway, "外部服务调用失败", null),

                TaskCanceledException =>
                    (HttpStatusCode.RequestTimeout, "请求已取消或超时", null),

                // SMTP相关异常
                _ when exception.GetType().Name.Contains("Smtp") =>
                    (HttpStatusCode.BadGateway, "邮件服务暂时不可用", null),

                // 默认情况
                _ => (HttpStatusCode.InternalServerError, "服务器内部错误", GetSafeExceptionDetails(exception))
            };
        }

        /// <summary>
        /// 获取安全的异常详细信息（过滤敏感信息）
        /// </summary>
        private object? GetSafeExceptionDetails(Exception exception)
        {
            if (!_environment.IsDevelopment())
                return null;

            // 过滤敏感信息的异常详情
            var safeMessage = FilterSensitiveInfo(exception.Message);

            return new
            {
                type = exception.GetType().Name,
                message = safeMessage,
                // 不包含StackTrace以避免路径泄露
            };
        }

        /// <summary>
        /// 过滤敏感信息
        /// </summary>
        private static string FilterSensitiveInfo(string message)
        {
            if (string.IsNullOrEmpty(message))
                return message;

            // 过滤常见的敏感信息模式
            var patterns = new[]
            {
                @"password[=:]\s*[^\s;,]+",  // 密码
                @"pwd[=:]\s*[^\s;,]+",      // 密码缩写
                @"token[=:]\s*[^\s;,]+",    // 令牌
                @"key[=:]\s*[^\s;,]+",      // 密钥
                @"secret[=:]\s*[^\s;,]+",   // 密钥
                @"connectionstring[=:]\s*[^\s;,]+", // 连接字符串
                @"[A-Za-z]:\\[^\\]*\\",     // Windows文件路径
                @"/[a-zA-Z0-9_\-./]+/",     // Linux文件路径
            };

            var filteredMessage = message;
            foreach (var pattern in patterns)
            {
                filteredMessage = System.Text.RegularExpressions.Regex.Replace(
                    filteredMessage, pattern, "[已过滤]",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            }

            return filteredMessage;
        }

        /// <summary>
        /// 获取客户端IP地址
        /// </summary>
        private static string GetClientIpAddress(HttpContext context)
        {
            var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
            if (!string.IsNullOrEmpty(forwardedFor))
                return forwardedFor.Split(',')[0].Trim();

            var realIp = context.Request.Headers["X-Real-IP"].FirstOrDefault();
            if (!string.IsNullOrEmpty(realIp))
                return realIp;

            return context.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }

        /// <summary>
        /// 获取请求ID
        /// </summary>
        private static string GetRequestId(HttpContext context)
        {
            return context.TraceIdentifier ?? Guid.NewGuid().ToString("N")[..8];
        }
    }

    /// <summary>
    /// 全局异常中间件扩展方法
    /// </summary>
    public static class GlobalExceptionMiddlewareExtensions
    {
        public static IApplicationBuilder UseGlobalExceptionHandler(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<GlobalExceptionMiddleware>();
        }
    }
}
```

#### 文件: Middleware\HostFilteringMiddleware.cs
```csharp
﻿using System.Net;

namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// 主机过滤中间件
    /// 限制允许访问的域名和IP，防止直接IP访问
    /// </summary>
    public class HostFilteringMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<HostFilteringMiddleware> _logger;
        private readonly HashSet<string> _allowedHosts;
        private readonly bool _allowLocalhostAccess;

        public HostFilteringMiddleware(
            RequestDelegate next,
            ILogger<HostFilteringMiddleware> logger,
            IConfiguration configuration)
        {
            _next = next;
            _logger = logger;

            // 从配置读取允许的主机
            var allowedHosts = configuration.GetSection("Security:AllowedHosts").Get<string[]>()
                ?? new[] { "notify.origami7023.cn", "localhost" };

            _allowedHosts = new HashSet<string>(allowedHosts, StringComparer.OrdinalIgnoreCase);

            // 是否允许本地访问（开发环境）
            _allowLocalhostAccess = configuration.GetValue<bool>("Security:AllowLocalhostAccess", true);
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var host = context.Request.Host.Host;
            var isAllowed = IsHostAllowed(host);

            if (!isAllowed)
            {
                _logger.LogWarning("拒绝非授权主机访问: {Host}, IP: {IP}, UserAgent: {UserAgent}",
                    context.Request.Host.Value,
                    GetClientIpAddress(context),
                    context.Request.Headers.UserAgent.FirstOrDefault());

                context.Response.StatusCode = 403;
                context.Response.ContentType = "application/json; charset=utf-8";

                await context.Response.WriteAsync(@"{
                    ""success"": false,
                    ""message"": ""访问被拒绝"",
                    ""errorCode"": ""HOST_NOT_ALLOWED"",
                    ""timestamp"": """ + DateTime.UtcNow.ToString("O") + @"""
                }");
                return;
            }

            await _next(context);
        }

        private bool IsHostAllowed(string host)
        {
            // 检查是否在允许列表中
            if (_allowedHosts.Contains(host))
                return true;

            // 开发环境允许localhost相关访问
            if (_allowLocalhostAccess && IsLocalhostAddress(host))
                return true;

            return false;
        }

        private static bool IsLocalhostAddress(string host)
        {
            // localhost 相关地址
            var localhostPatterns = new[]
            {
                "localhost",
                "127.0.0.1",
                "::1",
                "0.0.0.0"
            };

            return localhostPatterns.Any(pattern =>
                string.Equals(host, pattern, StringComparison.OrdinalIgnoreCase));
        }

        private static string GetClientIpAddress(HttpContext context)
        {
            var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
            if (!string.IsNullOrEmpty(forwardedFor))
                return forwardedFor.Split(',')[0].Trim();

            var realIp = context.Request.Headers["X-Real-IP"].FirstOrDefault();
            if (!string.IsNullOrEmpty(realIp))
                return realIp;

            return context.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }
    }

    public static class HostFilteringMiddlewareExtensions
    {
        public static IApplicationBuilder UseCustomHostFiltering(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<HostFilteringMiddleware>();
        }
    }
}
```

#### 文件: Middleware\RequestValidationMiddleware.cs
```csharp
﻿using System.Text;

namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// 请求验证中间件
    /// 验证请求大小、内容类型和恶意内容
    /// </summary>
    public class RequestValidationMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<RequestValidationMiddleware> _logger;
        private readonly long _maxRequestSize;
        private readonly HashSet<string> _allowedContentTypes;
        private readonly string[] _suspiciousPatterns;

        public RequestValidationMiddleware(
            RequestDelegate next,
            ILogger<RequestValidationMiddleware> logger,
            IConfiguration configuration)
        {
            _next = next;
            _logger = logger;

            _maxRequestSize = configuration.GetValue<long>("Security:MaxRequestSizeBytes", 1024 * 1024); // 1MB default

            _allowedContentTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "application/json",
                "application/x-www-form-urlencoded",
                "text/plain"
            };

            // 可疑模式检测
            _suspiciousPatterns = new[]
            {
                "<script",
                "javascript:",
                "vbscript:",
                "onload=",
                "onerror=",
                "eval(",
                "expression(",
                "../",
                "..\\",
                "union select",
                "drop table",
                "insert into",
                "delete from",
                "update set",
                "create table"
            };
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // 检查请求大小
            if (context.Request.ContentLength.HasValue &&
                context.Request.ContentLength.Value > _maxRequestSize)
            {
                _logger.LogWarning("请求大小超出限制: {Size} bytes, IP: {IP}",
                    context.Request.ContentLength.Value, GetClientIpAddress(context));

                await WriteErrorResponse(context, 413, "请求内容过大");
                return;
            }

            // 检查Content-Type（仅POST请求）
            if (context.Request.Method == "POST" &&
                !string.IsNullOrEmpty(context.Request.ContentType))
            {
                var contentType = context.Request.ContentType.Split(';')[0].Trim();
                if (!_allowedContentTypes.Contains(contentType))
                {
                    _logger.LogWarning("不支持的Content-Type: {ContentType}, IP: {IP}",
                        contentType, GetClientIpAddress(context));

                    await WriteErrorResponse(context, 415, "不支持的媒体类型");
                    return;
                }
            }

            // 检查查询字符串和用户代理
            if (await ContainsSuspiciousContent(context))
            {
                return; // 已在方法内处理响应
            }

            await _next(context);
        }

        private async Task<bool> ContainsSuspiciousContent(HttpContext context)
        {
            var suspicious = false;
            var suspiciousContent = new List<string>();

            // 检查查询字符串
            var queryString = context.Request.QueryString.Value;
            if (!string.IsNullOrEmpty(queryString))
            {
                foreach (var pattern in _suspiciousPatterns)
                {
                    if (queryString.Contains(pattern, StringComparison.OrdinalIgnoreCase))
                    {
                        suspicious = true;
                        suspiciousContent.Add($"QueryString: {pattern}");
                    }
                }
            }

            // 检查User-Agent
            var userAgent = context.Request.Headers.UserAgent.FirstOrDefault();
            if (!string.IsNullOrEmpty(userAgent))
            {
                // 检测常见的恶意爬虫或攻击工具
                var maliciousUserAgents = new[]
                {
                    "sqlmap", "nmap", "masscan", "nikto", "dirb", "gobuster",
                    "burpsuite", "owasp", "metasploit"
                };

                foreach (var malicious in maliciousUserAgents)
                {
                    if (userAgent.Contains(malicious, StringComparison.OrdinalIgnoreCase))
                    {
                        suspicious = true;
                        suspiciousContent.Add($"UserAgent: {malicious}");
                    }
                }
            }

            // 检查路径遍历
            var path = context.Request.Path.Value;
            if (!string.IsNullOrEmpty(path) && (path.Contains("../") || path.Contains("..\\") || path.Contains("%2e%2e")))
            {
                suspicious = true;
                suspiciousContent.Add("PathTraversal");
            }

            if (suspicious)
            {
                _logger.LogWarning("检测到可疑请求内容: {Content}, IP: {IP}, Path: {Path}",
                    string.Join(", ", suspiciousContent),
                    GetClientIpAddress(context),
                    context.Request.Path);

                await WriteErrorResponse(context, 400, "请求包含不允许的内容");
                return true;
            }

            return false;
        }

        private static string GetClientIpAddress(HttpContext context)
        {
            var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
            if (!string.IsNullOrEmpty(forwardedFor))
                return forwardedFor.Split(',')[0].Trim();

            var realIp = context.Request.Headers["X-Real-IP"].FirstOrDefault();
            if (!string.IsNullOrEmpty(realIp))
                return realIp;

            return context.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }

        private static async Task WriteErrorResponse(HttpContext context, int statusCode, string message)
        {
            context.Response.StatusCode = statusCode;
            context.Response.ContentType = "application/json; charset=utf-8";

            var response = new
            {
                success = false,
                message = message,
                timestamp = DateTime.UtcNow,
                requestId = Guid.NewGuid().ToString("N")[..8]
            };

            var jsonResponse = System.Text.Json.JsonSerializer.Serialize(response, new System.Text.Json.JsonSerializerOptions
            {
                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
                Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
            });

            await context.Response.WriteAsync(jsonResponse);
        }
    }

    public static class RequestValidationMiddlewareExtensions
    {
        public static IApplicationBuilder UseRequestValidation(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestValidationMiddleware>();
        }
    }
}
```

#### 文件: Middleware\SecurityHeadersMiddleware.cs
```csharp
﻿namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// 安全头中间件
    /// 添加安全相关的HTTP响应头，保护应用免受常见攻击
    /// </summary>
    public class SecurityHeadersMiddleware
    {
        private readonly RequestDelegate _next;

        public SecurityHeadersMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // 移除可能泄露服务器信息的头
            context.Response.Headers.Remove("Server");
            context.Response.Headers.Remove("X-Powered-By");
            context.Response.Headers.Remove("X-AspNetMvc-Version");
            context.Response.Headers.Remove("X-AspNet-Version");

            // 安全地添加安全头（避免重复添加）
            AddHeaderIfNotExists(context.Response.Headers, "X-Content-Type-Options", "nosniff");
            AddHeaderIfNotExists(context.Response.Headers, "X-Frame-Options", "DENY");
            AddHeaderIfNotExists(context.Response.Headers, "X-XSS-Protection", "1; mode=block");
            AddHeaderIfNotExists(context.Response.Headers, "Referrer-Policy", "strict-origin-when-cross-origin");

            // 内容安全策略 - 针对API服务的严格策略
            AddHeaderIfNotExists(context.Response.Headers, "Content-Security-Policy",
                "default-src 'none'; frame-ancestors 'none'; base-uri 'none'");

            // 权限策略 - 禁用不必要的浏览器功能
            AddHeaderIfNotExists(context.Response.Headers, "Permissions-Policy",
                "camera=(), microphone=(), geolocation=(), payment=()");

            // 严格传输安全 - 只在HTTPS且尚未存在时添加
            if (context.Request.IsHttps && !context.Response.Headers.ContainsKey("Strict-Transport-Security"))
            {
                context.Response.Headers.Add("Strict-Transport-Security",
                    "max-age=31536000; includeSubDomains; preload");
            }

            await _next(context);
        }

        /// <summary>
        /// 安全地添加响应头，如果不存在则添加
        /// </summary>
        private static void AddHeaderIfNotExists(IHeaderDictionary headers, string key, string value)
        {
            if (!headers.ContainsKey(key))
            {
                headers.Add(key, value);
            }
        }
    }

    /// <summary>
    /// 安全头中间件扩展方法
    /// </summary>
    public static class SecurityHeadersMiddlewareExtensions
    {
        /// <summary>
        /// 添加安全头中间件到请求管道
        /// </summary>
        public static IApplicationBuilder UseSecurityHeaders(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<SecurityHeadersMiddleware>();
        }
    }
}
```

#### 文件: Middleware\SecurityScanDetectionMiddleware.cs
```csharp
﻿using Microsoft.Extensions.Caching.Memory;
using System.Text.RegularExpressions;

namespace NotifyHubAPI.Middleware
{
    /// <summary>
    /// 安全扫描检测中间件
    /// 检测并阻断常见的漏洞扫描和恶意请求
    /// </summary>
    public class SecurityScanDetectionMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<SecurityScanDetectionMiddleware> _logger;
        private readonly IMemoryCache _cache;

        // 已知漏洞探测路径
        private readonly HashSet<string> _knownVulnPaths = new(StringComparer.OrdinalIgnoreCase)
        {
            "/solr/admin/collections", "/websso/SAML2/SSO/vsphere.local", "/smartbi/vision/RMIServlet",
            "/suite-api", "/uapjs/jsinvoke", "/console/", "/admin/", "/manager/", "/phpmyadmin/",
            "/.env", "/wp-admin/", "/wp-login.php", "/.git/", "/phpinfo.php", "/test.php",
            "/debug", "/actuator/", "/druid/", "/nacos/", "/jenkins/", "/grafana/",
            "/kibana/", "/elasticsearch/", "/redis/", "/mongodb/", "/mysql/", "/mssql/",
            "/oracle/", "/postgres/", "/memcached/", "/zookeeper/", "/kafka/",
            "/weblogic/", "/jboss/", "/tomcat/", "/glassfish/", "/wildfly/",
            "/struts/", "/spring/", "/hibernate/", "/mybatis/", "/fastjson/"
        };

        // 恶意载荷模式
        private readonly Regex[] _maliciousPatterns = new[]
        {
            new Regex(@"\$\{jndi:", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"\$\{.*:.*\}", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"<script.*?>", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"javascript:", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"union.*select", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"drop.*table", RegexOptions.IgnoreCase | RegexOptions.Compiled),
            new Regex(@"\.\.[\\/]", RegexOptions.Compiled),
            new Regex(@"%2e%2e", RegexOptions.IgnoreCase | RegexOptions.Compiled)
        };

        public SecurityScanDetectionMiddleware(
            RequestDelegate next,
            ILogger<SecurityScanDetectionMiddleware> logger,
            IMemoryCache cache)
        {
            _next = next;
            _logger = logger;
            _cache = cache;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var clientIp = GetClientIpAddress(context);
            var path = context.Request.Path.Value ?? "";
            var userAgent = context.Request.Headers.UserAgent.FirstOrDefault() ?? "";
            var referer = context.Request.Headers.Referer.FirstOrDefault() ?? "";

            // 检查是否为已知漏洞扫描路径
            if (IsKnownVulnPath(path))
            {
                await HandleSecurityScan(context, clientIp, "已知漏洞路径", path);
                return;
            }

            // 检查恶意载荷
            if (ContainsMaliciousPayload(path, userAgent, referer))
            {
                await HandleSecurityScan(context, clientIp, "恶意载荷", path);
                return;
            }

            // 检查是否为扫描器User-Agent
            if (IsScannerUserAgent(userAgent))
            {
                await HandleSecurityScan(context, clientIp, "扫描器特征", userAgent);
                return;
            }

            await _next(context);
        }

        private bool IsKnownVulnPath(string path)
        {
            return _knownVulnPaths.Any(vulnPath =>
                path.StartsWith(vulnPath, StringComparison.OrdinalIgnoreCase));
        }

        private bool ContainsMaliciousPayload(params string[] inputs)
        {
            foreach (var input in inputs)
            {
                if (string.IsNullOrEmpty(input)) continue;

                foreach (var pattern in _maliciousPatterns)
                {
                    if (pattern.IsMatch(input))
                        return true;
                }
            }
            return false;
        }

        private static bool IsScannerUserAgent(string userAgent)
        {
            if (string.IsNullOrEmpty(userAgent)) return false;

            var scannerPatterns = new[]
            {
                "sqlmap", "nmap", "masscan", "nikto", "dirb", "gobuster", "dirbuster",
                "burp", "owasp", "metasploit", "nessus", "openvas", "acunetix",
                "w3af", "skipfish", "arachni", "nuclei", "httpx", "subfinder"
            };

            return scannerPatterns.Any(pattern =>
                userAgent.Contains(pattern, StringComparison.OrdinalIgnoreCase));
        }

        private async Task HandleSecurityScan(HttpContext context, string clientIp, string type, string detail)
        {
            // 增加IP封禁计数
            var banKey = $"security_ban_{clientIp}";
            var currentCount = _cache.Get<int>(banKey);
            _cache.Set(banKey, currentCount + 1, TimeSpan.FromHours(24));

            // 记录安全扫描日志（降级为Debug级别避免刷屏）
            _logger.LogDebug("安全扫描检测 - IP: {IP}, 类型: {Type}, 详情: {Detail}, 计数: {Count}",
                clientIp, type, SanitizeLogInput(detail), currentCount + 1);

            // 直接返回403，不返回详细信息
            context.Response.StatusCode = 403;
            context.Response.ContentType = "text/plain";
            await context.Response.WriteAsync("Forbidden");
        }

        private static string GetClientIpAddress(HttpContext context)
        {
            var forwardedFor = context.Request.Headers["X-Forwarded-For"].FirstOrDefault();
            if (!string.IsNullOrEmpty(forwardedFor))
                return forwardedFor.Split(',')[0].Trim();

            var realIp = context.Request.Headers["X-Real-IP"].FirstOrDefault();
            if (!string.IsNullOrEmpty(realIp))
                return realIp;

            return context.Connection.RemoteIpAddress?.ToString() ?? "Unknown";
        }

        /// <summary>
        /// 清理日志输入，防止日志注入
        /// </summary>
        private static string SanitizeLogInput(string input)
        {
            if (string.IsNullOrEmpty(input)) return input;

            // 移除换行符和控制字符，限制长度
            return Regex.Replace(input, @"[\r\n\t]", "")
                       .Replace("${", "[FILTERED]")
                       .Take(100)
                       .Aggregate("", (acc, c) => acc + c);
        }
    }

    public static class SecurityScanDetectionMiddlewareExtensions
    {
        public static IApplicationBuilder UseSecurityScanDetection(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<SecurityScanDetectionMiddleware>();
        }
    }
}
```


### Models 文件夹
--------------------------------------------------

#### 文件: Models\ApiResponse.cs
```csharp
﻿namespace NotifyHubAPI.Models
{
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public T? Data { get; set; }
        public string? RequestId { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;

        public static ApiResponse<T> SuccessResult(T data, string message = "操作成功")
        {
            return new ApiResponse<T>
            {
                Success = true,
                Message = message,
                Data = data,
                RequestId = Guid.NewGuid().ToString("N")[..8]
            };
        }

        public static ApiResponse<T> FailureResult(string message, T? data = default)
        {
            return new ApiResponse<T>
            {
                Success = false,
                Message = message,
                Data = data,
                RequestId = Guid.NewGuid().ToString("N")[..8]
            };
        }
    }

    public class EmailSendResponse
    {
        public string EmailId { get; set; } = string.Empty;
        public EmailStatus Status { get; set; }
        public string Message { get; set; } = string.Empty;
    }
}
```

#### 文件: Models\EmailRecord.cs
```csharp
﻿using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace NotifyHubAPI.Models
{
    [Table("EmailRecords")]
    public class EmailRecord
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [StringLength(1000)]
        public string ToAddresses { get; set; } = string.Empty;

        [StringLength(1000)]
        public string? CcAddresses { get; set; }

        [StringLength(1000)]
        public string? BccAddresses { get; set; }

        [Required]
        [StringLength(500)]
        public string Subject { get; set; } = string.Empty;

        [Required]
        public string Body { get; set; } = string.Empty;

        public EmailPriority Priority { get; set; }

        [Required]
        [StringLength(100)]
        public string Category { get; set; } = string.Empty;

        public bool IsHtml { get; set; }

        public EmailStatus Status { get; set; } = EmailStatus.Pending;

        [StringLength(2000)]
        public string? ErrorMessage { get; set; }

        public int RetryCount { get; set; } = 0;

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public DateTime? SentAt { get; set; }

        public DateTime? LastRetryAt { get; set; }

        [Required]
        [StringLength(100)]
        public string ApiKey { get; set; } = string.Empty;

        [StringLength(50)]
        public string? RequestId { get; set; }
    }

    public enum EmailStatus
    {
        Pending = 0,
        Sent = 1,
        Failed = 2,
        Retrying = 3,
        Cancelled = 4
    }
}
```

#### 文件: Models\EmailRequest.cs
```csharp
﻿using System.ComponentModel.DataAnnotations;

namespace NotifyHubAPI.Models
{
    public class EmailRequest
    {
        [Required(ErrorMessage = "收件人不能为空")]
        public List<string> To { get; set; } = new();

        public List<string>? Cc { get; set; }

        public List<string>? Bcc { get; set; }

        [Required(ErrorMessage = "邮件主题不能为空")]
        [StringLength(500, ErrorMessage = "主题长度不能超过500字符")]
        public string Subject { get; set; } = string.Empty;

        [Required(ErrorMessage = "邮件内容不能为空")]
        [StringLength(50000, ErrorMessage = "邮件内容长度不能超过50000字符")]
        public string Body { get; set; } = string.Empty;

        public EmailPriority Priority { get; set; } = EmailPriority.Normal;

        [Required(ErrorMessage = "邮件分类不能为空")]
        [StringLength(100, ErrorMessage = "分类长度不能超过100字符")]
        public string Category { get; set; } = string.Empty;

        public bool IsHtml { get; set; } = false;

        public Dictionary<string, string>? Attachments { get; set; }
    }

    public enum EmailPriority
    {
        Low = 0,
        Normal = 1,
        High = 2
    }
}
```

#### 文件: Models\ErrorHandlingOptions.cs
```csharp
﻿namespace NotifyHubAPI.Models
{
    /// <summary>
    /// 错误处理配置选项
    /// </summary>
    public class ErrorHandlingOptions
    {
        public const string SectionName = "ErrorHandling";

        /// <summary>
        /// 是否在生产环境显示详细错误信息（默认：false）
        /// </summary>
        public bool ShowDetailedErrors { get; set; } = false;

        /// <summary>
        /// 是否记录敏感信息到日志（默认：false）
        /// </summary>
        public bool LogSensitiveData { get; set; } = false;

        /// <summary>
        /// 最大收件人数量限制（默认：100）
        /// </summary>
        public int MaxRecipients { get; set; } = 100;

        /// <summary>
        /// 邮件内容最大长度（默认：50000）
        /// </summary>
        public int MaxEmailBodyLength { get; set; } = 50000;

        /// <summary>
        /// 邮件主题最大长度（默认：500）
        /// </summary>
        public int MaxSubjectLength { get; set; } = 500;

        /// <summary>
        /// API密钥掩码长度（默认：4）
        /// </summary>
        public int ApiKeyMaskLength { get; set; } = 4;

        /// <summary>
        /// 需要过滤的敏感信息关键词
        /// </summary>
        public List<string> SensitiveKeywords { get; set; } = new()
        {
            "password",
            "pwd",
            "token",
            "key",
            "secret",
            "connectionstring",
            "smtp",
            "auth"
        };
    }
}
```

#### 文件: Models\StandardApiResponse.cs
```csharp
﻿namespace NotifyHubAPI.Models
{
    /// <summary>
    /// 标准化API响应模型
    /// 确保所有API端点返回一致的响应格式
    /// </summary>
    public class StandardApiResponse<T>
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public T? Data { get; set; }
        public string RequestId { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string? ErrorCode { get; set; }
        public object? Details { get; set; } // 仅开发环境使用

        /// <summary>
        /// 创建成功响应
        /// </summary>
        public static StandardApiResponse<T> CreateSuccess(T data, string message = "操作成功")
        {
            return new StandardApiResponse<T>
            {
                Success = true,
                Message = message,
                Data = data,
                RequestId = GenerateRequestId()
            };
        }

        /// <summary>
        /// 创建失败响应
        /// </summary>
        public static StandardApiResponse<T> CreateFailure(
            string message,
            ApiErrorCode errorCode = ApiErrorCode.Unknown,
            T? data = default,
            object? details = null)
        {
            return new StandardApiResponse<T>
            {
                Success = false,
                Message = message,
                Data = data,
                ErrorCode = errorCode.ToString(),
                Details = details,
                RequestId = GenerateRequestId()
            };
        }

        /// <summary>
        /// 创建验证错误响应
        /// </summary>
        public static StandardApiResponse<T> CreateValidationError(
            string message,
            Dictionary<string, string[]>? validationErrors = null)
        {
            return new StandardApiResponse<T>
            {
                Success = false,
                Message = message,
                ErrorCode = ApiErrorCode.ValidationError.ToString(),
                Details = validationErrors,
                RequestId = GenerateRequestId()
            };
        }

        /// <summary>
        /// 创建授权失败响应
        /// </summary>
        public static StandardApiResponse<T> CreateUnauthorized(string message = "未授权访问")
        {
            return new StandardApiResponse<T>
            {
                Success = false,
                Message = message,
                ErrorCode = ApiErrorCode.Unauthorized.ToString(),
                RequestId = GenerateRequestId()
            };
        }

        /// <summary>
        /// 创建服务器内部错误响应
        /// </summary>
        public static StandardApiResponse<T> CreateServerError(
            string message = "服务器内部错误",
            object? details = null)
        {
            return new StandardApiResponse<T>
            {
                Success = false,
                Message = message,
                ErrorCode = ApiErrorCode.ServerError.ToString(),
                Details = details,
                RequestId = GenerateRequestId()
            };
        }

        /// <summary>
        /// 创建外部服务错误响应
        /// </summary>
        public static StandardApiResponse<T> CreateExternalServiceError(string message = "外部服务调用失败")
        {
            return new StandardApiResponse<T>
            {
                Success = false,
                Message = message,
                ErrorCode = ApiErrorCode.ExternalServiceError.ToString(),
                RequestId = GenerateRequestId()
            };
        }

        private static string GenerateRequestId()
        {
            return Guid.NewGuid().ToString("N")[..8];
        }
    }

    /// <summary>
    /// API错误代码枚举
    /// 提供结构化的错误分类
    /// </summary>
    public enum ApiErrorCode
    {
        // 通用错误
        Unknown = 1000,
        ValidationError = 1001,
        InvalidParameter = 1002,

        // 认证授权错误
        Unauthorized = 2001,
        InvalidApiKey = 2002,
        MissingApiKey = 2003,
        RateLimitExceeded = 2004,

        // 邮件服务错误
        EmailSendFailed = 3001,
        SmtpConnectionFailed = 3002,
        InvalidEmailFormat = 3003,
        EmailSizeExceeded = 3004,

        // 系统错误
        ServerError = 5001,
        DatabaseError = 5002,
        ExternalServiceError = 5003,
        ConfigurationError = 5004,
        ServiceUnavailable = 5005
    }

    /// <summary>
    /// 健康检查响应模型
    /// </summary>
    public class HealthCheckResponse
    {
        public string Status { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string Version { get; set; } = string.Empty;
        public string Environment { get; set; } = string.Empty;
        public Dictionary<string, object>? Components { get; set; }
    }
}
```


### Services 文件夹
--------------------------------------------------

#### 文件: Services\ApiKeyService.cs
```csharp
﻿using Microsoft.Extensions.Options;

namespace NotifyHubAPI.Services
{
    public interface IApiKeyService
    {
        /// <summary>
        /// 验证API密钥是否有效
        /// </summary>
        /// <param name="apiKey">API密钥</param>
        /// <returns>是否有效</returns>
        bool IsValidApiKey(string apiKey);

        /// <summary>
        /// 根据API密钥获取项目名称
        /// </summary>
        /// <param name="apiKey">API密钥</param>
        /// <returns>项目名称，如果不存在返回null</returns>
        string? GetProjectByApiKey(string apiKey);

        /// <summary>
        /// 获取所有有效的API密钥
        /// </summary>
        /// <returns>API密钥字典</returns>
        Dictionary<string, string> GetAllApiKeys();
    }

    public class ApiKeyService : IApiKeyService
    {
        private readonly Dictionary<string, string> _apiKeys;
        private readonly ILogger<ApiKeyService> _logger;

        public ApiKeyService(IConfiguration configuration, ILogger<ApiKeyService> logger)
        {
            _logger = logger;
            _apiKeys = new Dictionary<string, string>();

            // 只从环境变量读取，不再使用配置文件作为后备
            LoadFromEnvironmentVariables();

            if (_apiKeys.Count == 0)
            {
                var errorMessage = "严重错误：未找到任何环境变量中的API密钥配置。请检查以下环境变量是否正确设置：NOTIFYHUB_APIKEY_DEFAULT, NOTIFYHUB_APIKEY_FMS_DATA_PROCESSOR";
                _logger.LogError(errorMessage);
                throw new InvalidOperationException(errorMessage);
            }

            _logger.LogInformation("已从环境变量加载 {Count} 个API密钥配置", _apiKeys.Count);
        }

        private void LoadFromEnvironmentVariables()
        {
            var envVars = Environment.GetEnvironmentVariables()
                .Cast<System.Collections.DictionaryEntry>()
                .Where(kv => kv.Key.ToString()?.StartsWith("NOTIFYHUB_APIKEY_DEFAULT") == true)
                .ToList();

            foreach (var envVar in envVars)
            {
                var key = envVar.Key.ToString();
                var value = envVar.Value?.ToString();

                if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value))
                    continue;

                // 提取项目名称: NOTIFYHUB_APIKEY_DEFAULT -> DEFAULT
                var projectName = key.Substring("NOTIFYHUB_APIKEY_DEFAULT".Length);

                _apiKeys[value] = projectName;
                _logger.LogInformation("已从环境变量加载API密钥，项目: {ProjectName}", projectName);
            }
        }

        public bool IsValidApiKey(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey))
                return false;

            var isValid = _apiKeys.ContainsKey(apiKey);

            if (!isValid)
            {
                _logger.LogWarning("无效的API密钥访问尝试: {ApiKey}",
                    apiKey.Length > 8 ? apiKey[..8] + "..." : apiKey);
            }

            return isValid;
        }

        public string? GetProjectByApiKey(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey))
                return null;

            return _apiKeys.TryGetValue(apiKey, out var projectName) ? projectName : null;
        }

        public Dictionary<string, string> GetAllApiKeys()
        {
            return _apiKeys.ToDictionary(kvp => kvp.Value, kvp => kvp.Key);
        }
    }
}
```

#### 文件: Services\EmailService.cs
```csharp
﻿using MailKit.Net.Smtp;
using MailKit.Security;
using MimeKit;
using MimeKit.Text;

namespace NotifyHubAPI.Services
{
    public class SimpleEmailService : IEmailService
    {
        private readonly SmtpSettings _smtpSettings;
        private readonly ILogger<SimpleEmailService> _logger;

        public SimpleEmailService(
            IOptions<SmtpSettings> smtpSettings,
            ILogger<SimpleEmailService> logger)
        {
            _smtpSettings = smtpSettings.Value;
            _logger = logger;
        }

        public async Task<EmailSendResponse> SendEmailAsync(EmailRequest emailRequest, string apiKey, CancellationToken cancellationToken = default)
        {
            var requestId = Guid.NewGuid().ToString("N")[..8];
            var emailId = Guid.NewGuid();

            _logger.LogInformation("开始发送邮件，RequestId: {RequestId}, Category: {Category}", requestId, emailRequest.Category);

            try
            {
                // 直接发送邮件，不保存到数据库
                await SendEmailInternalAsync(emailRequest, cancellationToken);

                _logger.LogInformation("邮件发送成功，EmailId: {EmailId}, RequestId: {RequestId}", emailId, requestId);

                return new EmailSendResponse
                {
                    EmailId = emailId.ToString(),
                    Status = EmailStatus.Sent,
                    Message = "邮件发送成功"
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "邮件发送失败，EmailId: {EmailId}, RequestId: {RequestId}", emailId, requestId);

                return new EmailSendResponse
                {
                    EmailId = emailId.ToString(),
                    Status = EmailStatus.Failed,
                    Message = $"邮件发送失败: {ex.Message}"
                };
            }
        }

        public Task<bool> RetryEmailAsync(Guid emailId, CancellationToken cancellationToken = default)
        {
            _logger.LogWarning("简化版本不支持邮件重试功能");
            return Task.FromResult(false);
        }

        public Task<EmailRecord?> GetEmailStatusAsync(Guid emailId)
        {
            _logger.LogWarning("简化版本不支持邮件状态查询");
            return Task.FromResult<EmailRecord?>(null);
        }

        public Task<List<EmailRecord>> GetPendingRetryEmailsAsync(int maxRetryCount, int retryDelayMinutes)
        {
            return Task.FromResult(new List<EmailRecord>());
        }

        public Task<(List<EmailRecord> Records, int TotalCount)> GetEmailHistoryAsync(
            string? category = null,
            EmailStatus? status = null,
            DateTime? startDate = null,
            DateTime? endDate = null,
            int pageIndex = 1,
            int pageSize = 20)
        {
            return Task.FromResult((new List<EmailRecord>(), 0));
        }

        private async Task SendEmailInternalAsync(EmailRequest emailRequest, CancellationToken cancellationToken = default)
        {
            var message = new MimeMessage();

            // 设置发件人
            message.From.Add(new MailboxAddress(_smtpSettings.FromName, _smtpSettings.FromEmail));

            // 设置收件人
            foreach (var to in emailRequest.To)
            {
                message.To.Add(MailboxAddress.Parse(to.Trim()));
            }

            // 设置抄送
            if (emailRequest.Cc?.Any() == true)
            {
                foreach (var cc in emailRequest.Cc)
                {
                    message.Cc.Add(MailboxAddress.Parse(cc.Trim()));
                }
            }

            // 设置密送
            if (emailRequest.Bcc?.Any() == true)
            {
                foreach (var bcc in emailRequest.Bcc)
                {
                    message.Bcc.Add(MailboxAddress.Parse(bcc.Trim()));
                }
            }

            // 设置主题
            message.Subject = emailRequest.Subject;

            // 设置优先级
            message.Priority = emailRequest.Priority switch
            {
                EmailPriority.High => MessagePriority.Urgent,
                EmailPriority.Low => MessagePriority.NonUrgent,
                _ => MessagePriority.Normal
            };

            // 设置邮件正文
            var textFormat = emailRequest.IsHtml ? TextFormat.Html : TextFormat.Plain;
            message.Body = new TextPart(textFormat)
            {
                Text = emailRequest.Body
            };

            // 发送邮件
            using var smtpClient = new SmtpClient();

            try
            {
                // 连接到SMTP服务器
                await smtpClient.ConnectAsync(_smtpSettings.Host, _smtpSettings.Port,
                    _smtpSettings.UseSsl ? SecureSocketOptions.StartTls : SecureSocketOptions.None, cancellationToken);

                // 身份验证
                await smtpClient.AuthenticateAsync(_smtpSettings.Username, _smtpSettings.Password, cancellationToken);

                // 发送邮件
                await smtpClient.SendAsync(message, cancellationToken);

                _logger.LogInformation("SMTP邮件发送成功");
            }
            finally
            {
                if (smtpClient.IsConnected)
                {
                    await smtpClient.DisconnectAsync(true, cancellationToken);
                }
            }
        }
    }
}
```

#### 文件: Services\IEmailService.cs
```csharp
﻿using NotifyHubAPI.Models;

namespace NotifyHubAPI.Services
{
    public interface IEmailService
    {
        /// <summary>
        /// 发送邮件
        /// </summary>
        /// <param name="emailRequest">邮件请求</param>
        /// <param name="apiKey">API密钥</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>邮件发送响应</returns>
        Task<EmailSendResponse> SendEmailAsync(EmailRequest emailRequest, string apiKey, CancellationToken cancellationToken = default);

        /// <summary>
        /// 重试发送失败的邮件
        /// </summary>
        /// <param name="emailId">邮件ID</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>是否重试成功</returns>
        Task<bool> RetryEmailAsync(Guid emailId, CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取邮件发送状态
        /// </summary>
        /// <param name="emailId">邮件ID</param>
        /// <returns>邮件记录</returns>
        Task<EmailRecord?> GetEmailStatusAsync(Guid emailId);

        /// <summary>
        /// 获取待重试的邮件列表
        /// </summary>
        /// <param name="maxRetryCount">最大重试次数</param>
        /// <param name="retryDelayMinutes">重试延迟分钟数</param>
        /// <returns>待重试的邮件列表</returns>
        Task<List<EmailRecord>> GetPendingRetryEmailsAsync(int maxRetryCount, int retryDelayMinutes);

        /// <summary>
        /// 获取邮件发送历史
        /// </summary>
        /// <param name="category">分类</param>
        /// <param name="status">状态</param>
        /// <param name="startDate">开始日期</param>
        /// <param name="endDate">结束日期</param>
        /// <param name="pageIndex">页码</param>
        /// <param name="pageSize">页大小</param>
        /// <returns>邮件历史记录</returns>
        Task<(List<EmailRecord> Records, int TotalCount)> GetEmailHistoryAsync(
            string? category = null,
            EmailStatus? status = null,
            DateTime? startDate = null,
            DateTime? endDate = null,
            int pageIndex = 1,
            int pageSize = 20);
    }
}
```

#### 文件: Services\SmtpSettings.cs
```csharp
﻿namespace NotifyHubAPI.Services
{
    public class SmtpSettings
    {
        public string Host { get; set; } = string.Empty;
        public int Port { get; set; }
        public bool UseSsl { get; set; }
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
        public string FromEmail { get; set; } = string.Empty;
        public string FromName { get; set; } = string.Empty;
    }
}
```
